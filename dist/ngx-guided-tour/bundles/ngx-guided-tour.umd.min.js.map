{"version":3,"sources":["ng://ngx-guided-tour/lib/guided-tour.constants.ts","ng://ngx-guided-tour/lib/windowref.service.ts","ng://ngx-guided-tour/lib/guided-tour.service.ts","ng://ngx-guided-tour/lib/guided-tour.component.ts","ng://ngx-guided-tour/lib/guided-tour.module.ts"],"names":["Orientation","Bottom","BottomLeft","BottomRight","Center","Left","Right","Top","TopLeft","TopRight","InsideNextButton","TopOfTourBlock","None","WindowRefService","Object","defineProperty","prototype","this","isBrowser","getWindow","window","innerWidth","innerHeight","scrollY","scrollX","pageYOffset","pageXOffset","scroll","scrollTo","addEventListener","removeEventListener","Injectable","Inject","args","PLATFORM_ID","platformId","isPlatformBrowser","GuidedTourService","nextStep","_this","_currentTour","steps","_currentTourStepIndex","closeAction","_setFirstAndLast","action","setTimeout","_checkSelectorValidity","_guidedTourCurrentStepSubject","next","getPreparedTourStep","completeCallback","resetTour","backStep","skipTour","skipCallback","dom","body","classList","remove","startTour","tour","cloneDeep","filter","step","skipStep","_guidedTourOrbShowingSubject","useOrb","length","minimumScreenSize","windowRef","nativeWindow","add","activateOrb","_onLastStep","_onFirstStep","selector","querySelector","errorHandler","handleError","Error","tourId","_onResizeMessage","preventBackdropFromAdvancing","index","setTourOrientation","convertedStep","orientation","sort","a","b","maximumSize","currentOrientation_1","forEach","orientationConfig","orientationDirection","ErrorHandler","DOCUMENT","Subject","guidedTourCurrentStepStream","asObservable","guidedTourOrbShowingStream","fromEvent","pipe","debounceTime","subscribe","dialog","resizeDialog","title","content","GuidedTourComponent","tourStepWidth","minimalTourStepWidth","tourStep","adjustment","calculatedLeftPosition","Math","min","maxWidthAdjustmentForTourStep","widthAdjustmentForScreenBound","ngAfterViewInit","guidedTourService","currentTourStep","scrollToAndSetElement","selectedElementRect","value","isOrbShowing","resizeSubscription","updateStepLocation","scrollSubscription","ngOnDestroy","unsubscribe","isTourOnScreen","isBottom","topPos","top","topOfPageAdjustment","scrollAdjustment","getStepScreenAdjustment","left","behavior","err","TypeError","height","handleOrb","elementInViewport","nativeElement","element","offsetTop","offsetHeight","offsetParent","backdropClick","event","stopPropagation","selectedElement","getBoundingClientRect","paddingAdjustment","getHighlightPadding","right","width","max","maxAdjustment","useHighlightPadding","highlightPadding","tourStepHeight","elementHeight","Component","template","encapsulation","ViewEncapsulation","Input","ViewChild","static","skipText","nextText","doneText","closeText","backText","progressIndicatorLocation","ProgressIndicatorLocation","progressIndicator","undefined","progressIndicatorLocations","GuidedTourModule","forRoot","ngModule","providers","NgModule","declarations","imports","CommonModule","exports","entryComponents"],"mappings":"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","sourcesContent":["\nexport interface TourStep {\n    /** Selector for element that will be highlighted */\n    selector?: string;\n    /** Tour title text */\n    title?: string;\n    /** Tour step text */\n    content: string;\n    /** Where the tour step will appear next to the selected element */\n    orientation?: Orientation | OrientationConfiguration[];\n    /** Action that happens when the step is opened */\n    action?: () => void;\n    /** Action that happens when the step is closed */\n    closeAction?: () => void;\n    /** Skips this step, this is so you do not have create multiple tour configurations based on user settings/configuration */\n    skipStep?: boolean;\n    /** Adds some padding for things like sticky headers when scrolling to an element */\n    scrollAdjustment?: number;\n    /** Adds default padding around tour highlighting. Does not need to be true for highlightPadding to work */\n    useHighlightPadding?: boolean;\n    /** Adds padding around tour highlighting in pixels, this overwrites the default for this step. Is not dependent on useHighlightPadding being true */\n    highlightPadding?: number;\n}\n\nexport interface GuidedTour {\n    /** Identifier for tour */\n    tourId: string;\n    /** Use orb to start tour */\n    useOrb?: boolean;\n    /** Steps fo the tour */\n    steps: TourStep[];\n    /** Function will be called when tour is skipped */\n    skipCallback?: (stepSkippedOn: number) => void;\n    /** Function will be called when tour is completed */\n    completeCallback?: () => void;\n    /** Minimum size of screen in pixels before the tour is run, if the tour is resized below this value the user will be told to resize */\n    minimumScreenSize?: number;\n    /** Dialog shown if the window width is smaller than the defined minimum screen size. */\n    resizeDialog?: {\n        /** Resize dialog title text */\n        title?: string;\n        /** Resize dialog text */\n        content: string;\n    }\n    /**\n     * Prevents the tour from advancing by clicking the backdrop.\n     * This should only be set if you are completely sure your tour is displaying correctly on all screen sizes otherwise a user can get stuck.\n     */\n    preventBackdropFromAdvancing?: boolean;\n}\n\nexport interface OrientationConfiguration {\n    /** Where the tour step will appear next to the selected element */\n    orientationDirection: Orientation;\n    /** When this orientation configuration starts in pixels */\n    maximumSize?: number;\n}\n\nexport class Orientation {\n    public static readonly Bottom = 'bottom';\n    public static readonly BottomLeft = 'bottom-left';\n    public static readonly BottomRight = 'bottom-right';\n    public static readonly Center = 'center';\n    public static readonly Left = 'left';\n    public static readonly Right = 'right';\n    public static readonly Top = 'top';\n    public static readonly TopLeft = 'top-left';\n    public static readonly TopRight = 'top-right';\n}\n\nexport enum ProgressIndicatorLocation {\n    InsideNextButton = 'inside-next-button',\n    TopOfTourBlock = 'top-of-tour-block',\n    None = 'none',\n}  \n","import { Inject, Injectable, PLATFORM_ID } from \"@angular/core\";\nimport { isPlatformBrowser } from \"@angular/common\";\n\nfunction getWindow(): any {\n    return window;\n}\n\nfunction getMockWindow(): any {\n    return {\n        innerWidth: 0,\n        innerHeight: 0,\n        scrollY: 0,\n        scrollX: 0,\n        pageYOffset: 0,\n        pageXOffset: 0,\n        scroll: () => {},\n        scrollTo: () => {},\n        addEventListener: () => {},\n        removeEventListener: () => {},\n    }\n}\n\n@Injectable()\nexport class WindowRefService {\n    private readonly isBrowser: boolean = false;\n\n    get nativeWindow(): any {\n        if (this.isBrowser) {\n            return getWindow();\n        } else {\n            return getMockWindow();\n        }\n    }\n\n    constructor(@Inject(PLATFORM_ID) platformId) {\n        this.isBrowser = isPlatformBrowser(platformId);\n    }\n}\n","import { debounceTime } from 'rxjs/operators';\nimport { ErrorHandler, Inject, Injectable } from '@angular/core';\nimport { Observable, Subject, fromEvent } from 'rxjs';\nimport { GuidedTour, TourStep, Orientation, OrientationConfiguration } from './guided-tour.constants';\nimport cloneDeep from 'lodash/cloneDeep';\nimport { DOCUMENT } from \"@angular/common\";\nimport { WindowRefService } from \"./windowref.service\";\n\n@Injectable()\nexport class GuidedTourService {\n    public guidedTourCurrentStepStream: Observable<TourStep>;\n    public guidedTourOrbShowingStream: Observable<boolean>;\n\n    private _guidedTourCurrentStepSubject = new Subject<TourStep>();\n    private _guidedTourOrbShowingSubject = new Subject<boolean>();\n    private _currentTourStepIndex = 0;\n    private _currentTour: GuidedTour = null;\n    private _onFirstStep = true;\n    private _onLastStep = true;\n    private _onResizeMessage = false;\n\n    constructor(\n        public errorHandler: ErrorHandler,\n        private windowRef: WindowRefService,\n        @Inject(DOCUMENT) private dom\n    ) {\n        this.guidedTourCurrentStepStream = this._guidedTourCurrentStepSubject.asObservable();\n        this.guidedTourOrbShowingStream = this._guidedTourOrbShowingSubject.asObservable();\n\n        fromEvent(this.windowRef.nativeWindow, 'resize').pipe(debounceTime(200)).subscribe(() => {\n            if (this._currentTour && this._currentTourStepIndex > -1) {\n                if (this._currentTour.minimumScreenSize && this._currentTour.minimumScreenSize >= this.windowRef.nativeWindow.innerWidth) {\n                    this._onResizeMessage = true;\n                    const dialog = this._currentTour.resizeDialog || {\n                        title: 'Please resize',\n                        content: 'You have resized the tour to a size that is too small to continue. Please resize the browser to a larger size to continue the tour or close the tour.'\n                    };\n\n                    this._guidedTourCurrentStepSubject.next(dialog);\n                } else {\n                    this._onResizeMessage = false;\n                    this._guidedTourCurrentStepSubject.next(this.getPreparedTourStep(this._currentTourStepIndex));\n                }\n            }\n        });\n    }\n\n    public nextStep(): void {\n        if (this._currentTour.steps[this._currentTourStepIndex].closeAction) {\n            this._currentTour.steps[this._currentTourStepIndex].closeAction();\n        }\n        if (this._currentTour.steps[this._currentTourStepIndex + 1]) {\n            this._currentTourStepIndex++;\n            this._setFirstAndLast();\n            if (this._currentTour.steps[this._currentTourStepIndex].action) {\n                this._currentTour.steps[this._currentTourStepIndex].action();\n                // Usually an action is opening something so we need to give it time to render.\n                setTimeout(() => {\n                    if (this._checkSelectorValidity()) {\n                        this._guidedTourCurrentStepSubject.next(this.getPreparedTourStep(this._currentTourStepIndex));\n                    } else {\n                        this.nextStep();\n                    }\n                });\n            } else {\n                if (this._checkSelectorValidity()) {\n                    this._guidedTourCurrentStepSubject.next(this.getPreparedTourStep(this._currentTourStepIndex));\n                } else {\n                    this.nextStep();\n                }\n            }\n        } else {\n            if (this._currentTour.completeCallback) {\n                this._currentTour.completeCallback();\n            }\n            this.resetTour();\n        }\n    }\n\n    public backStep(): void {\n        if (this._currentTour.steps[this._currentTourStepIndex].closeAction) {\n            this._currentTour.steps[this._currentTourStepIndex].closeAction();\n        }\n        if (this._currentTour.steps[this._currentTourStepIndex - 1]) {\n            this._currentTourStepIndex--;\n            this._setFirstAndLast();\n            if (this._currentTour.steps[this._currentTourStepIndex].action) {\n                this._currentTour.steps[this._currentTourStepIndex].action();\n                setTimeout(() => {\n                    if (this._checkSelectorValidity()) {\n                        this._guidedTourCurrentStepSubject.next(this.getPreparedTourStep(this._currentTourStepIndex));\n                    } else {\n                        this.backStep();\n                    }\n                });\n            } else {\n                if (this._checkSelectorValidity()) {\n                    this._guidedTourCurrentStepSubject.next(this.getPreparedTourStep(this._currentTourStepIndex));\n                } else {\n                    this.backStep();\n                }\n            }\n        } else {\n            this.resetTour();\n        }\n    }\n\n    public skipTour(): void {\n        if (this._currentTour.skipCallback) {\n            this._currentTour.skipCallback(this._currentTourStepIndex);\n        }\n        this.resetTour();\n    }\n\n    public resetTour(): void {\n        this.dom.body.classList.remove('tour-open');\n        this._currentTour = null;\n        this._currentTourStepIndex = 0;\n        this._guidedTourCurrentStepSubject.next(null);\n    }\n\n    public startTour(tour: GuidedTour): void {\n        this._currentTour = cloneDeep(tour);\n        this._currentTour.steps = this._currentTour.steps.filter(step => !step.skipStep);\n        this._currentTourStepIndex = 0;\n        this._setFirstAndLast();\n        this._guidedTourOrbShowingSubject.next(this._currentTour.useOrb);\n        if (\n            this._currentTour.steps.length > 0\n            && (!this._currentTour.minimumScreenSize\n                || (this.windowRef.nativeWindow.innerWidth >= this._currentTour.minimumScreenSize))\n        ) {\n            if (!this._currentTour.useOrb) {\n                this.dom.body.classList.add('tour-open');\n            }\n            if (this._currentTour.steps[this._currentTourStepIndex].action) {\n                this._currentTour.steps[this._currentTourStepIndex].action();\n            }\n            if (this._checkSelectorValidity()) {\n                this._guidedTourCurrentStepSubject.next(this.getPreparedTourStep(this._currentTourStepIndex));\n            } else {\n                this.nextStep();\n            }\n        }\n    }\n\n    public activateOrb(): void {\n        this._guidedTourOrbShowingSubject.next(false);\n        this.dom.body.classList.add('tour-open');\n    }\n\n    private _setFirstAndLast(): void {\n        this._onLastStep = (this._currentTour.steps.length - 1) === this._currentTourStepIndex;\n        this._onFirstStep = this._currentTourStepIndex === 0;\n    }\n\n    private _checkSelectorValidity(): boolean {\n        if (this._currentTour.steps[this._currentTourStepIndex].selector) {\n            const selectedElement = this.dom.querySelector(this._currentTour.steps[this._currentTourStepIndex].selector);\n            if (!selectedElement) {\n                this.errorHandler.handleError(\n                    // If error handler is configured this should not block the browser.\n                    new Error(`Error finding selector ${this._currentTour.steps[this._currentTourStepIndex].selector} on step ${this._currentTourStepIndex + 1} during guided tour: ${this._currentTour.tourId}`)\n                );\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public get onLastStep(): boolean {\n        return this._onLastStep;\n    }\n\n    public get onFirstStep(): boolean {\n        return this._onFirstStep;\n    }\n\n    public get onResizeMessage(): boolean {\n        return this._onResizeMessage;\n    }\n\n    public get currentTourStepDisplay(): number {\n        return this._currentTourStepIndex + 1;\n    }\n\n    public get currentTourStepCount(): number {\n        return this._currentTour && this._currentTour.steps ? this._currentTour.steps.length : 0;\n    }\n\n    public get preventBackdropFromAdvancing(): boolean {\n        return this._currentTour && this._currentTour.preventBackdropFromAdvancing;\n    }\n\n    private getPreparedTourStep(index: number): TourStep {\n        return this.setTourOrientation(this._currentTour.steps[index]);\n    }\n\n    private setTourOrientation(step: TourStep): TourStep {\n        const convertedStep = cloneDeep(step);\n        if (\n            convertedStep.orientation\n            && !(typeof convertedStep.orientation === 'string')\n            && (convertedStep.orientation as OrientationConfiguration[]).length\n        ) {\n            (convertedStep.orientation as OrientationConfiguration[]).sort((a: OrientationConfiguration, b: OrientationConfiguration) => {\n                if (!b.maximumSize) {\n                    return 1;\n                }\n                if (!a.maximumSize) {\n                    return -1;\n                }\n                return b.maximumSize - a.maximumSize;\n            });\n\n            let currentOrientation: Orientation = Orientation.Top;\n            (convertedStep.orientation as OrientationConfiguration[]).forEach(\n                (orientationConfig: OrientationConfiguration) => {\n                    if (!orientationConfig.maximumSize || this.windowRef.nativeWindow.innerWidth <= orientationConfig.maximumSize) {\n                        currentOrientation = orientationConfig.orientationDirection;\n                    }\n                }\n            );\n\n            convertedStep.orientation = currentOrientation;\n        }\n        return convertedStep;\n    }\n}\n","import { AfterViewInit, Component, ElementRef, Input, OnDestroy, ViewChild, ViewEncapsulation, TemplateRef, Inject } from '@angular/core';\nimport { fromEvent, Subscription } from 'rxjs';\nimport { DOCUMENT } from '@angular/common';\nimport { Orientation, TourStep, ProgressIndicatorLocation } from './guided-tour.constants';\nimport { GuidedTourService } from './guided-tour.service';\nimport { WindowRefService } from \"./windowref.service\";\n\n@Component({\n    selector: 'ngx-guided-tour',\n    template: `\n        <div *ngIf=\"currentTourStep && selectedElementRect && isOrbShowing\"\n                (mouseenter)=\"handleOrb()\"\n                class=\"tour-orb tour-{{ currentTourStep.orientation }}\"\n                [style.top.px]=\"orbTopPosition\"\n                [style.left.px]=\"orbLeftPosition\"\n                [style.transform]=\"orbTransform\">\n                <div class=\"tour-orb-ring\"></div>\n        </div>\n        <div *ngIf=\"currentTourStep && !isOrbShowing\">\n            <div class=\"guided-tour-user-input-mask\" (click)=\"backdropClick($event)\"></div>\n            <div class=\"guided-tour-spotlight-overlay\"\n                [style.top.px]=\"overlayTop\"\n                [style.left.px]=\"overlayLeft\"\n                [style.height.px]=\"overlayHeight\"\n                [style.width.px]=\"overlayWidth\">\n            </div>\n        </div>\n        <div *ngIf=\"currentTourStep && !isOrbShowing\">\n            <div #tourStep *ngIf=\"currentTourStep\"\n                class=\"tour-step tour-{{ currentTourStep.orientation }}\"\n                [ngClass]=\"{\n                    'page-tour-step': !currentTourStep.selector\n                }\"\n                [style.top.px]=\"(currentTourStep.selector && selectedElementRect ? topPosition : null)\"\n                [style.left.px]=\"(currentTourStep.selector && selectedElementRect ? leftPosition : null)\"\n                [style.width.px]=\"(currentTourStep.selector && selectedElementRect ? calculatedTourStepWidth : null)\"\n                [style.transform]=\"(currentTourStep.selector && selectedElementRect ? transform : null)\">\n                <div *ngIf=\"currentTourStep.selector\" class=\"tour-arrow\"></div>\n                <div class=\"tour-block\">\n                    <div *ngIf=\"\n                        progressIndicatorLocation === progressIndicatorLocations.TopOfTourBlock\n                        && !guidedTourService.onResizeMessage\"\n                    class=\"tour-progress-indicator\">\n                        <ng-container *ngTemplateOutlet=\"progress\"></ng-container>\n                    </div>\n                    <h3 class=\"tour-title\" *ngIf=\"currentTourStep.title && currentTourStep.selector\">\n                        {{ currentTourStep.title }}\n                    </h3>\n                    <h2 class=\"tour-title\" *ngIf=\"currentTourStep.title && !currentTourStep.selector\">\n                        {{ currentTourStep.title }}\n                    </h2>\n                    <div class=\"tour-content\" [innerHTML]=\"currentTourStep.content\"></div>\n                    <div class=\"tour-buttons\">\n                        <button *ngIf=\"!guidedTourService.onResizeMessage\"\n                            (click)=\"guidedTourService.skipTour()\"\n                            class=\"skip-button link-button\">\n                            {{ skipText }}\n                        </button>\n                        <button *ngIf=\"!guidedTourService.onLastStep && !guidedTourService.onResizeMessage\"\n                            class=\"next-button\"\n                            (click)=\"guidedTourService.nextStep()\">\n                            {{ nextText }}\n                            <ng-container *ngIf=\"progressIndicatorLocation === progressIndicatorLocations.InsideNextButton\">\n                                <ng-container *ngTemplateOutlet=\"progress\"></ng-container>\n                            </ng-container>\n                        </button>\n                        <button *ngIf=\"guidedTourService.onLastStep\"\n                            class=\"next-button\"\n                            (click)=\"guidedTourService.nextStep()\">\n                            {{ doneText }}\n                        </button>\n\n                        <button *ngIf=\"guidedTourService.onResizeMessage\"\n                            class=\"next-button\"\n                            (click)=\"guidedTourService.resetTour()\">\n                            {{ closeText }}\n                        </button>\n                        <button *ngIf=\"!guidedTourService.onFirstStep && !guidedTourService.onResizeMessage\"\n                            class=\"back-button link-button\"\n                            (click)=\"guidedTourService.backStep()\">\n                            {{ backText }}\n                        </button>\n                    </div>\n                </div>\n            </div>\n        </div>\n        <ng-template #progress>\n            <ng-container *ngTemplateOutlet=\"\n                progressIndicator || defaultProgressIndicator; \n                context: { currentStepNumber: guidedTourService.currentTourStepDisplay, totalSteps: guidedTourService.currentTourStepCount }\n            \"></ng-container> \n        </ng-template>\n        <ng-template #defaultProgressIndicator let-currentStepNumber=\"currentStepNumber\" let-totalSteps=\"totalSteps\">\n            <ng-container *ngIf=\"progressIndicatorLocation === progressIndicatorLocations.InsideNextButton\">&nbsp;</ng-container>{{ currentStepNumber }}/{{ totalSteps }}\n        </ng-template>\n    `,\n    styleUrls: ['./guided-tour.component.scss'],\n    encapsulation: ViewEncapsulation.None\n})\nexport class GuidedTourComponent implements AfterViewInit, OnDestroy {\n    @Input() public topOfPageAdjustment ?= 0;\n    @Input() public tourStepWidth ?= 300;\n    @Input() public minimalTourStepWidth ?= 200;\n    @Input() public skipText ?= 'Skip';\n    @Input() public nextText ?= 'Next';\n    @Input() public doneText ?= 'Done';\n    @Input() public closeText ?= 'Close';\n    @Input() public backText ?= 'Back';\n    @Input() public progressIndicatorLocation?: ProgressIndicatorLocation = ProgressIndicatorLocation.InsideNextButton;\n    @Input() public progressIndicator?: TemplateRef<any> = undefined;\n    @ViewChild('tourStep', { static: false }) public tourStep: ElementRef;\n    public highlightPadding = 4;\n    public currentTourStep: TourStep = null;\n    public selectedElementRect: DOMRect = null;\n    public isOrbShowing = false;\n    public progressIndicatorLocations = ProgressIndicatorLocation;\n\n    private resizeSubscription: Subscription;\n    private scrollSubscription: Subscription;\n\n    constructor(\n        public guidedTourService: GuidedTourService,\n        private windowRef: WindowRefService,\n        @Inject(DOCUMENT) private dom: any\n    ) { }\n\n    private get maxWidthAdjustmentForTourStep(): number {\n        return this.tourStepWidth - this.minimalTourStepWidth;\n    }\n\n    private get widthAdjustmentForScreenBound(): number {\n        if (!this.tourStep) {\n            return 0;\n        }\n        let adjustment = 0;\n        if (this.calculatedLeftPosition < 0) {\n            adjustment = -this.calculatedLeftPosition;\n        }\n        if (this.calculatedLeftPosition > this.windowRef.nativeWindow.innerWidth - this.tourStepWidth) {\n            adjustment = this.calculatedLeftPosition - (this.windowRef.nativeWindow.innerWidth - this.tourStepWidth);\n        }\n\n        return Math.min(this.maxWidthAdjustmentForTourStep, adjustment);\n    }\n\n    public get calculatedTourStepWidth() {\n        return this.tourStepWidth - this.widthAdjustmentForScreenBound;\n    }\n\n    public ngAfterViewInit(): void {\n        this.guidedTourService.guidedTourCurrentStepStream.subscribe((step: TourStep) => {\n            this.currentTourStep = step;\n            if (step && step.selector) {\n                const selectedElement = this.dom.querySelector(step.selector);\n                if (selectedElement) {\n                    this.scrollToAndSetElement();\n                } else {\n                    this.selectedElementRect = null;\n                }\n            } else {\n                this.selectedElementRect = null;\n            }\n        });\n\n        this.guidedTourService.guidedTourOrbShowingStream.subscribe((value: boolean) => {\n            this.isOrbShowing = value;\n        });\n\n        this.resizeSubscription = fromEvent(this.windowRef.nativeWindow, 'resize').subscribe(() => {\n            this.updateStepLocation();\n        });\n\n        this.scrollSubscription = fromEvent(this.windowRef.nativeWindow, 'scroll').subscribe(() => {\n            this.updateStepLocation();\n        });\n    }\n\n    public ngOnDestroy(): void {\n        this.resizeSubscription.unsubscribe();\n        this.scrollSubscription.unsubscribe();\n    }\n\n    public scrollToAndSetElement(): void {\n        this.updateStepLocation();\n        // Allow things to render to scroll to the correct location\n        setTimeout(() => {\n            if (!this.isOrbShowing && !this.isTourOnScreen()) {\n                if (this.selectedElementRect && this.isBottom()) {\n                    // Scroll so the element is on the top of the screen.\n                    const topPos = ((this.windowRef.nativeWindow.scrollY + this.selectedElementRect.top) - this.topOfPageAdjustment)\n                        - (this.currentTourStep.scrollAdjustment ? this.currentTourStep.scrollAdjustment : 0)\n                        + this.getStepScreenAdjustment();\n                    try {\n                        this.windowRef.nativeWindow.scrollTo({\n                            left: null,\n                            top: topPos,\n                            behavior: 'smooth'\n                        });\n                    } catch (err) {\n                        if (err instanceof TypeError) {\n                            this.windowRef.nativeWindow.scroll(0, topPos);\n                        } else {\n                            throw err;\n                        }\n                    }\n                } else {\n                    // Scroll so the element is on the bottom of the screen.\n                    const topPos = (this.windowRef.nativeWindow.scrollY + this.selectedElementRect.top + this.selectedElementRect.height)\n                        - this.windowRef.nativeWindow.innerHeight\n                        + (this.currentTourStep.scrollAdjustment ? this.currentTourStep.scrollAdjustment : 0)\n                        - this.getStepScreenAdjustment();\n                    try {\n                        this.windowRef.nativeWindow.scrollTo({\n                            left: null,\n                            top: topPos,\n                            behavior: 'smooth'\n                        });\n                    } catch (err) {\n                        if (err instanceof TypeError) {\n                            this.windowRef.nativeWindow.scroll(0, topPos);\n                        } else {\n                            throw err;\n                        }\n                    }\n                }\n            }\n        });\n    }\n\n    public handleOrb(): void {\n        this.guidedTourService.activateOrb();\n        if (this.currentTourStep && this.currentTourStep.selector) {\n            this.scrollToAndSetElement();\n        }\n    }\n\n    private isTourOnScreen(): boolean {\n        return this.tourStep\n            && this.elementInViewport(this.dom.querySelector(this.currentTourStep.selector))\n            && this.elementInViewport(this.tourStep.nativeElement);\n    }\n\n    // Modified from https://stackoverflow.com/questions/123999/how-to-tell-if-a-dom-element-is-visible-in-the-current-viewport\n    private elementInViewport(element: HTMLElement): boolean {\n        let top = element.offsetTop;\n        const height = element.offsetHeight;\n\n        while (element.offsetParent) {\n            element = (element.offsetParent as HTMLElement);\n            top += element.offsetTop;\n        }\n        if (this.isBottom()) {\n            return (\n                top >= (this.windowRef.nativeWindow.pageYOffset\n                    + this.topOfPageAdjustment\n                    + (this.currentTourStep.scrollAdjustment ? this.currentTourStep.scrollAdjustment : 0)\n                    + this.getStepScreenAdjustment())\n                && (top + height) <= (this.windowRef.nativeWindow.pageYOffset + this.windowRef.nativeWindow.innerHeight)\n            );\n        } else {\n            return (\n                top >= (this.windowRef.nativeWindow.pageYOffset + this.topOfPageAdjustment - this.getStepScreenAdjustment())\n                && (top + height + (this.currentTourStep.scrollAdjustment ? this.currentTourStep.scrollAdjustment : 0)) <= (this.windowRef.nativeWindow.pageYOffset + this.windowRef.nativeWindow.innerHeight)\n            );\n        }\n    }\n\n    public backdropClick(event: Event): void {\n        if (this.guidedTourService.preventBackdropFromAdvancing) {\n            event.stopPropagation();\n        } else {\n            this.guidedTourService.nextStep();\n        }\n    }\n\n    public updateStepLocation(): void {\n        if (this.currentTourStep && this.currentTourStep.selector) {\n            const selectedElement = this.dom.querySelector(this.currentTourStep.selector);\n            if (selectedElement && typeof selectedElement.getBoundingClientRect === 'function') {\n                this.selectedElementRect = (selectedElement.getBoundingClientRect() as DOMRect);\n            } else {\n                this.selectedElementRect = null;\n            }\n        } else {\n            this.selectedElementRect = null;\n        }\n    }\n\n    private isBottom(): boolean {\n        return this.currentTourStep.orientation\n            && (this.currentTourStep.orientation === Orientation.Bottom\n            || this.currentTourStep.orientation === Orientation.BottomLeft\n            || this.currentTourStep.orientation === Orientation.BottomRight);\n    }\n\n    public get topPosition(): number {\n        const paddingAdjustment = this.getHighlightPadding();\n\n        if (this.isBottom()) {\n            return this.selectedElementRect.top + this.selectedElementRect.height + paddingAdjustment;\n        }\n\n        return this.selectedElementRect.top - this.getHighlightPadding();\n    }\n\n    public get orbTopPosition(): number {\n        if (this.isBottom()) {\n            return this.selectedElementRect.top + this.selectedElementRect.height;\n        }\n\n        if (\n            this.currentTourStep.orientation === Orientation.Right\n            || this.currentTourStep.orientation === Orientation.Left\n        ) {\n            return (this.selectedElementRect.top + (this.selectedElementRect.height / 2));\n        }\n\n        return this.selectedElementRect.top;\n    }\n\n    private get calculatedLeftPosition(): number {\n        const paddingAdjustment = this.getHighlightPadding();\n\n        if (\n            this.currentTourStep.orientation === Orientation.TopRight\n            || this.currentTourStep.orientation === Orientation.BottomRight\n        ) {\n            return (this.selectedElementRect.right - this.tourStepWidth);\n        }\n\n        if (\n            this.currentTourStep.orientation === Orientation.TopLeft\n            || this.currentTourStep.orientation === Orientation.BottomLeft\n        ) {\n            return (this.selectedElementRect.left);\n        }\n\n        if (this.currentTourStep.orientation === Orientation.Left) {\n            return this.selectedElementRect.left - this.tourStepWidth - paddingAdjustment;\n        }\n\n        if (this.currentTourStep.orientation === Orientation.Right) {\n            return (this.selectedElementRect.left + this.selectedElementRect.width + paddingAdjustment);\n        }\n\n        return (this.selectedElementRect.right - (this.selectedElementRect.width / 2) - (this.tourStepWidth / 2));\n    }\n\n    public get leftPosition(): number {\n        if (this.calculatedLeftPosition >= 0) {\n            return this.calculatedLeftPosition;\n        }\n        const adjustment = Math.max(0, -this.calculatedLeftPosition)\n        const maxAdjustment = Math.min(this.maxWidthAdjustmentForTourStep, adjustment);\n        return this.calculatedLeftPosition + maxAdjustment;\n    }\n\n    public get orbLeftPosition(): number {\n        if (\n            this.currentTourStep.orientation === Orientation.TopRight\n            || this.currentTourStep.orientation === Orientation.BottomRight\n        ) {\n            return this.selectedElementRect.right;\n        }\n\n        if (\n            this.currentTourStep.orientation === Orientation.TopLeft\n            || this.currentTourStep.orientation === Orientation.BottomLeft\n        ) {\n            return this.selectedElementRect.left;\n        }\n\n        if (this.currentTourStep.orientation === Orientation.Left) {\n            return this.selectedElementRect.left;\n        }\n\n        if (this.currentTourStep.orientation === Orientation.Right) {\n            return (this.selectedElementRect.left + this.selectedElementRect.width);\n        }\n\n        return (this.selectedElementRect.right - (this.selectedElementRect.width / 2));\n    }\n\n    public get transform(): string {\n        if (\n            !this.currentTourStep.orientation\n            || this.currentTourStep.orientation === Orientation.Top\n            || this.currentTourStep.orientation === Orientation.TopRight\n            || this.currentTourStep.orientation === Orientation.TopLeft\n        ) {\n            return 'translateY(-100%)';\n        }\n        return null;\n    }\n\n    public get orbTransform(): string {\n        if (\n            !this.currentTourStep.orientation\n            || this.currentTourStep.orientation === Orientation.Top\n            || this.currentTourStep.orientation === Orientation.Bottom\n            || this.currentTourStep.orientation === Orientation.TopLeft\n            || this.currentTourStep.orientation === Orientation.BottomLeft\n        ) {\n            return 'translateY(-50%)';\n        }\n\n        if (\n            this.currentTourStep.orientation === Orientation.TopRight\n            || this.currentTourStep.orientation === Orientation.BottomRight\n        ) {\n            return 'translate(-100%, -50%)';\n        }\n\n        if (\n            this.currentTourStep.orientation === Orientation.Right\n            || this.currentTourStep.orientation === Orientation.Left\n        ) {\n            return 'translate(-50%, -50%)';\n        }\n\n        return null;\n    }\n\n    public get overlayTop(): number {\n        if (this.selectedElementRect) {\n            return this.selectedElementRect.top - this.getHighlightPadding();\n        }\n        return 0;\n    }\n\n    public get overlayLeft(): number {\n        if (this.selectedElementRect) {\n            return this.selectedElementRect.left - this.getHighlightPadding();\n        }\n        return 0;\n    }\n\n    public get overlayHeight(): number {\n        if (this.selectedElementRect) {\n            return this.selectedElementRect.height + (this.getHighlightPadding() * 2);\n        }\n        return 0;\n    }\n\n    public get overlayWidth(): number {\n        if (this.selectedElementRect) {\n            return this.selectedElementRect.width + (this.getHighlightPadding() * 2);\n        }\n        return 0;\n    }\n\n    private getHighlightPadding(): number {\n        let paddingAdjustment = this.currentTourStep.useHighlightPadding ? this.highlightPadding : 0;\n        if (this.currentTourStep.highlightPadding) {\n            paddingAdjustment = this.currentTourStep.highlightPadding;\n        }\n        return paddingAdjustment;\n    }\n\n    // This calculates a value to add or subtract so the step should not be off screen.\n    private getStepScreenAdjustment(): number {\n        if (\n            this.currentTourStep.orientation === Orientation.Left\n            || this.currentTourStep.orientation === Orientation.Right\n        ) {\n            return 0;\n        }\n\n        const scrollAdjustment = this.currentTourStep.scrollAdjustment ? this.currentTourStep.scrollAdjustment : 0;\n        const tourStepHeight = typeof this.tourStep.nativeElement.getBoundingClientRect === 'function' ? this.tourStep.nativeElement.getBoundingClientRect().height : 0;\n        const elementHeight = this.selectedElementRect.height + scrollAdjustment + tourStepHeight;\n\n        if ((this.windowRef.nativeWindow.innerHeight - this.topOfPageAdjustment) < elementHeight) {\n            return elementHeight - (this.windowRef.nativeWindow.innerHeight - this.topOfPageAdjustment);\n        }\n        return 0;\n    }\n}\n","import { GuidedTourService } from './guided-tour.service';\nimport { GuidedTourComponent } from './guided-tour.component';\nimport { NgModule, ErrorHandler, ModuleWithProviders } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { WindowRefService } from './windowref.service';\n\n@NgModule({\n  declarations: [GuidedTourComponent],\n  imports: [CommonModule],\n  providers: [WindowRefService],\n  exports: [GuidedTourComponent],\n  entryComponents: [GuidedTourComponent],\n})\nexport class GuidedTourModule {\n  public static forRoot(): ModuleWithProviders {\n    return {\n      ngModule: GuidedTourModule,\n      providers: [ErrorHandler, GuidedTourService],\n    };\n  }\n}\n"]}